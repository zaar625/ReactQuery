{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nimport { isArray, isEmptyObject, isMap, isPlainObject, isPrimitive, isSet } from './is';\nimport { escapeKey, stringifyPath } from './pathstringifier';\nimport { isInstanceOfRegisteredClass, transformValue, untransformValue } from './transformer';\nimport { includes, forEach } from './util';\nimport { parsePath } from './pathstringifier';\nimport { getDeep, setDeep } from './accessDeep';\nfunction traverse(tree, walker, origin) {\n  if (origin === void 0) {\n    origin = [];\n  }\n  if (!tree) {\n    return;\n  }\n  if (!isArray(tree)) {\n    forEach(tree, function (subtree, key) {\n      return traverse(subtree, walker, __spreadArray(__spreadArray([], __read(origin)), __read(parsePath(key))));\n    });\n    return;\n  }\n  var _a = __read(tree, 2),\n    nodeValue = _a[0],\n    children = _a[1];\n  if (children) {\n    forEach(children, function (child, key) {\n      traverse(child, walker, __spreadArray(__spreadArray([], __read(origin)), __read(parsePath(key))));\n    });\n  }\n  walker(nodeValue, origin);\n}\nexport function applyValueAnnotations(plain, annotations, superJson) {\n  traverse(annotations, function (type, path) {\n    plain = setDeep(plain, path, function (v) {\n      return untransformValue(v, type, superJson);\n    });\n  });\n  return plain;\n}\nexport function applyReferentialEqualityAnnotations(plain, annotations) {\n  function apply(identicalPaths, path) {\n    var object = getDeep(plain, parsePath(path));\n    identicalPaths.map(parsePath).forEach(function (identicalObjectPath) {\n      plain = setDeep(plain, identicalObjectPath, function () {\n        return object;\n      });\n    });\n  }\n  if (isArray(annotations)) {\n    var _a = __read(annotations, 2),\n      root = _a[0],\n      other = _a[1];\n    root.forEach(function (identicalPath) {\n      plain = setDeep(plain, parsePath(identicalPath), function () {\n        return plain;\n      });\n    });\n    if (other) {\n      forEach(other, apply);\n    }\n  } else {\n    forEach(annotations, apply);\n  }\n  return plain;\n}\nvar isDeep = function (object, superJson) {\n  return isPlainObject(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);\n};\nfunction addIdentity(object, path, identities) {\n  var existingSet = identities.get(object);\n  if (existingSet) {\n    existingSet.push(path);\n  } else {\n    identities.set(object, [path]);\n  }\n}\nexport function generateReferentialEqualityAnnotations(identitites) {\n  var result = {};\n  var rootEqualityPaths = undefined;\n  identitites.forEach(function (paths) {\n    if (paths.length <= 1) {\n      return;\n    }\n    var _a = __read(paths.map(function (path) {\n        return path.map(String);\n      }).sort(function (a, b) {\n        return a.length - b.length;\n      })),\n      shortestPath = _a[0],\n      identicalPaths = _a.slice(1);\n    if (shortestPath.length === 0) {\n      rootEqualityPaths = identicalPaths.map(stringifyPath);\n    } else {\n      result[stringifyPath(shortestPath)] = identicalPaths.map(stringifyPath);\n    }\n  });\n  if (rootEqualityPaths) {\n    if (isEmptyObject(result)) {\n      return [rootEqualityPaths];\n    } else {\n      return [rootEqualityPaths, result];\n    }\n  } else {\n    return isEmptyObject(result) ? undefined : result;\n  }\n}\nexport var walker = function (object, identities, superJson, path, objectsInThisPath) {\n  var _a;\n  if (path === void 0) {\n    path = [];\n  }\n  if (objectsInThisPath === void 0) {\n    objectsInThisPath = [];\n  }\n  if (!isPrimitive(object)) {\n    addIdentity(object, path, identities);\n  }\n  if (!isDeep(object, superJson)) {\n    var transformed_1 = transformValue(object, superJson);\n    if (transformed_1) {\n      return {\n        transformedValue: transformed_1.value,\n        annotations: [transformed_1.type]\n      };\n    } else {\n      return {\n        transformedValue: object\n      };\n    }\n  }\n  if (includes(objectsInThisPath, object)) {\n    return {\n      transformedValue: null\n    };\n  }\n  var transformationResult = transformValue(object, superJson);\n  var transformed = (_a = transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.value) !== null && _a !== void 0 ? _a : object;\n  if (!isPrimitive(object)) {\n    objectsInThisPath = __spreadArray(__spreadArray([], __read(objectsInThisPath)), [object]);\n  }\n  var transformedValue = isArray(transformed) ? [] : {};\n  var innerAnnotations = {};\n  forEach(transformed, function (value, index) {\n    var recursiveResult = walker(value, identities, superJson, __spreadArray(__spreadArray([], __read(path)), [index]), objectsInThisPath);\n    transformedValue[index] = recursiveResult.transformedValue;\n    if (isArray(recursiveResult.annotations)) {\n      innerAnnotations[index] = recursiveResult.annotations;\n    } else if (isPlainObject(recursiveResult.annotations)) {\n      forEach(recursiveResult.annotations, function (tree, key) {\n        innerAnnotations[escapeKey(index) + '.' + key] = tree;\n      });\n    }\n  });\n  if (isEmptyObject(innerAnnotations)) {\n    return {\n      transformedValue: transformedValue,\n      annotations: !!transformationResult ? [transformationResult.type] : undefined\n    };\n  } else {\n    return {\n      transformedValue: transformedValue,\n      annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations\n    };\n  }\n};","map":{"version":3,"sources":["../../src/plainer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nimport { isArray, isEmptyObject, isMap, isPlainObject, isPrimitive, isSet, } from './is';\nimport { escapeKey, stringifyPath } from './pathstringifier';\nimport { isInstanceOfRegisteredClass, transformValue, untransformValue, } from './transformer';\nimport { includes, forEach } from './util';\nimport { parsePath } from './pathstringifier';\nimport { getDeep, setDeep } from './accessDeep';\nfunction traverse(tree, walker, origin) {\n    if (origin === void 0) { origin = []; }\n    if (!tree) {\n        return;\n    }\n    if (!isArray(tree)) {\n        forEach(tree, function (subtree, key) {\n            return traverse(subtree, walker, __spreadArray(__spreadArray([], __read(origin)), __read(parsePath(key))));\n        });\n        return;\n    }\n    var _a = __read(tree, 2), nodeValue = _a[0], children = _a[1];\n    if (children) {\n        forEach(children, function (child, key) {\n            traverse(child, walker, __spreadArray(__spreadArray([], __read(origin)), __read(parsePath(key))));\n        });\n    }\n    walker(nodeValue, origin);\n}\nexport function applyValueAnnotations(plain, annotations, superJson) {\n    traverse(annotations, function (type, path) {\n        plain = setDeep(plain, path, function (v) { return untransformValue(v, type, superJson); });\n    });\n    return plain;\n}\nexport function applyReferentialEqualityAnnotations(plain, annotations) {\n    function apply(identicalPaths, path) {\n        var object = getDeep(plain, parsePath(path));\n        identicalPaths.map(parsePath).forEach(function (identicalObjectPath) {\n            plain = setDeep(plain, identicalObjectPath, function () { return object; });\n        });\n    }\n    if (isArray(annotations)) {\n        var _a = __read(annotations, 2), root = _a[0], other = _a[1];\n        root.forEach(function (identicalPath) {\n            plain = setDeep(plain, parsePath(identicalPath), function () { return plain; });\n        });\n        if (other) {\n            forEach(other, apply);\n        }\n    }\n    else {\n        forEach(annotations, apply);\n    }\n    return plain;\n}\nvar isDeep = function (object, superJson) {\n    return isPlainObject(object) ||\n        isArray(object) ||\n        isMap(object) ||\n        isSet(object) ||\n        isInstanceOfRegisteredClass(object, superJson);\n};\nfunction addIdentity(object, path, identities) {\n    var existingSet = identities.get(object);\n    if (existingSet) {\n        existingSet.push(path);\n    }\n    else {\n        identities.set(object, [path]);\n    }\n}\nexport function generateReferentialEqualityAnnotations(identitites) {\n    var result = {};\n    var rootEqualityPaths = undefined;\n    identitites.forEach(function (paths) {\n        if (paths.length <= 1) {\n            return;\n        }\n        var _a = __read(paths\n            .map(function (path) { return path.map(String); })\n            .sort(function (a, b) { return a.length - b.length; })), shortestPath = _a[0], identicalPaths = _a.slice(1);\n        if (shortestPath.length === 0) {\n            rootEqualityPaths = identicalPaths.map(stringifyPath);\n        }\n        else {\n            result[stringifyPath(shortestPath)] = identicalPaths.map(stringifyPath);\n        }\n    });\n    if (rootEqualityPaths) {\n        if (isEmptyObject(result)) {\n            return [rootEqualityPaths];\n        }\n        else {\n            return [rootEqualityPaths, result];\n        }\n    }\n    else {\n        return isEmptyObject(result) ? undefined : result;\n    }\n}\nexport var walker = function (object, identities, superJson, path, objectsInThisPath) {\n    var _a;\n    if (path === void 0) { path = []; }\n    if (objectsInThisPath === void 0) { objectsInThisPath = []; }\n    if (!isPrimitive(object)) {\n        addIdentity(object, path, identities);\n    }\n    if (!isDeep(object, superJson)) {\n        var transformed_1 = transformValue(object, superJson);\n        if (transformed_1) {\n            return {\n                transformedValue: transformed_1.value,\n                annotations: [transformed_1.type]\n            };\n        }\n        else {\n            return {\n                transformedValue: object\n            };\n        }\n    }\n    if (includes(objectsInThisPath, object)) {\n        return {\n            transformedValue: null\n        };\n    }\n    var transformationResult = transformValue(object, superJson);\n    var transformed = (_a = transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.value) !== null && _a !== void 0 ? _a : object;\n    if (!isPrimitive(object)) {\n        objectsInThisPath = __spreadArray(__spreadArray([], __read(objectsInThisPath)), [object]);\n    }\n    var transformedValue = isArray(transformed) ? [] : {};\n    var innerAnnotations = {};\n    forEach(transformed, function (value, index) {\n        var recursiveResult = walker(value, identities, superJson, __spreadArray(__spreadArray([], __read(path)), [index]), objectsInThisPath);\n        transformedValue[index] = recursiveResult.transformedValue;\n        if (isArray(recursiveResult.annotations)) {\n            innerAnnotations[index] = recursiveResult.annotations;\n        }\n        else if (isPlainObject(recursiveResult.annotations)) {\n            forEach(recursiveResult.annotations, function (tree, key) {\n                innerAnnotations[escapeKey(index) + '.' + key] = tree;\n            });\n        }\n    });\n    if (isEmptyObject(innerAnnotations)) {\n        return {\n            transformedValue: transformedValue,\n            annotations: !!transformationResult\n                ? [transformationResult.type]\n                : undefined\n        };\n    }\n    else {\n        return {\n            transformedValue: transformedValue,\n            annotations: !!transformationResult\n                ? [transformationResult.type, innerAnnotations]\n                : innerAnnotations\n        };\n    }\n};\n//# sourceMappingURL=plainer.js.map"]},"metadata":{},"sourceType":"module"}